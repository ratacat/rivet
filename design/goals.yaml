# ABOUTME: Defines the goals and purpose of the terminology system
# ABOUTME: What we're trying to accomplish and why

primary_goal: |
  Give automated structure for AIs integrating with a codebase,
  specifically around linguistic noise and drift, reducing confusion
  and hallucinations.

philosophy: |
  Rivet is fundamentally concerned with what IS - the current state of
  the architecture, the current names, the current requirements. Not what
  was (historical cruft) or what should be (aspirational docs).

  History matters only insofar as it clarifies what actually is. A
  deprecation note exists to explain the current state ("this is being
  replaced"), not to preserve archaeology. When something is gone, it's
  gone from Rivet.

  This keeps Rivet small, accurate, and useful. It's a living snapshot,
  not a museum.

secondary_goals:
  architecture_tracking: |
    Maintain living architecture definitions that stay current as code
    changes. While vibe coding, you should always be able to point to
    a well-defined architecture document. As scope changes, refactors
    happen, things get renamed - the architecture stays accurate.

  requirements_persistence: |
    Keep requirements married to the systems they describe, moving
    forward through a changing environment. When things get refactored
    or renamed, requirements don't get lost - they travel with the
    system or get explicitly handled.

    Requirements have similar value to tests - an LLM can look at
    requirements, look at the system, and verify they match. That's
    high-value stuff worth preserving.

constraints:
  - This is a disambiguation system, not a documentation system
  - Only things that cause confusion deserve entries
  - Smaller is better - excessive entries create more noise than signal
  - Systems only, not every method/interface

threshold_for_entry:
  - Multiple files with clear boundary (a "system")
  - Has been confused before (reactive, not proactive documentation)
  - Non-obvious name or overlaps with similar concepts

what_is_a_system: |
  A system is a cohesive bundle of code that forms a single mental model.

  Criteria:
  - Has clear boundaries (you can point to where it starts and ends)
  - Forms a coherent abstraction (the pieces "fit together" conceptually)
  - Substantial size (~5% of codebase, or significant enough to cause confusion)
  - Has a name worth tracking (you'd mention it when explaining architecture)

  A system is something you'd draw as a box in an architecture diagram.
  It's what you'd explain to a new team member as "the X that handles Y."

  NOT a system:
  - Individual functions or methods (use live scan via rivet check)
  - Utility helpers without conceptual identity
  - Single files that are just implementation details
  - Things too small to have a "name" worth locking

  When in doubt: if it's caused confusion before, or has a name that could
  drift or be misused, it's probably worth an entry. If not, leave it out.
