# ABOUTME: Defines the goals and purpose of the terminology system
# ABOUTME: What we're trying to accomplish and why

why_language_matters: |
  In the age of AI-assisted software development, words are first-class citizens.
  They always have been - "what happens when someone else reads this code?" or
  "what happens when I read this in two weeks?" - but now there's a new reader:
  the AI. And AIs take language literally in ways humans don't.

  The scope of use for our primary instruments in software development is
  expanding. Previously, naming only mattered for human comprehension. Now it
  also determines whether an AI hallucinates, drifts, or stays grounded.

  Companies like SpaceX famously control vocabulary - no new acronym without
  approval. This isn't bureaucracy; it's recognition that language is, as the
  saying goes, "the liquid we're all dissolved in." How can you have a
  functional conversation - with a human or an AI - if you can't agree on the
  meaning of things?

  Rivet exists to lock in your language. Not everything - just the things that
  matter. The systems, the concepts, the terms that define your architecture.
  Once locked, they don't drift. They mean what you said they mean.

primary_goal: |
  Give automated structure for AIs integrating with a codebase,
  specifically around linguistic noise and drift, reducing confusion
  and hallucinations.

philosophy: |
  Rivet is fundamentally concerned with what IS - the current state of
  the architecture, the current names, the current requirements. Not what
  was (historical cruft) or what should be (aspirational docs).

  History matters only insofar as it clarifies what actually is. A
  deprecation note exists to explain the current state ("this is being
  replaced"), not to preserve archaeology. When something is gone, it's
  gone from Rivet.

  This keeps Rivet small, accurate, and useful. It's a living snapshot,
  not a museum.

secondary_goals:
  architecture_tracking: |
    Maintain living architecture definitions that stay current as code
    changes. While vibe coding, you should always be able to point to
    a well-defined architecture document. As scope changes, refactors
    happen, things get renamed - the architecture stays accurate.

  requirements_persistence: |
    Keep requirements married to the systems they describe, moving
    forward through a changing environment. When things get refactored
    or renamed, requirements don't get lost - they travel with the
    system or get explicitly handled.

    Requirements have similar value to tests - an LLM can look at
    requirements, look at the system, and verify they match. That's
    high-value stuff worth preserving.

constraints:
  - This is a disambiguation system, not a documentation system
  - Only things that cause confusion deserve entries
  - Smaller is better - excessive entries create more noise than signal
  - Systems only, not every method/interface

what_rivet_prevents:
  premature_reification: |
    When casual language gets formalized before agreement. Someone says
    "we should cache this" and suddenly there's a Cache class. Or a verb
    ("we lock terms") becomes a noun (a Lock command). Rivet's locked
    terminology prevents this drift by making naming decisions explicit
    and agreed-upon before they enter the codebase.

key_requirement: |
  At the end of a context session, ALL changes must be capturable in a single
  rivet sync command. Systems, requirements, decisions, terms, glossary -
  everything from the conversation goes into one atomic batch operation.

  Example end-of-session command:
    rivet sync \
      --add Router "handles URL routing" \
      --require Router "must support nested routes" \
      --decide Router "async-first for scale" \
      --term Router createRouter \
      --define vibe_coding "AI handles implementation while human guides"

threshold_for_entry:
  - Multiple files with clear boundary (a "system")
  - Has been confused before (reactive, not proactive documentation)
  - Non-obvious name or overlaps with similar concepts

what_is_a_system: |
  A system is a cohesive bundle of code that forms a single mental model.

  Criteria:
  - Has clear boundaries (you can point to where it starts and ends)
  - Forms a coherent abstraction (the pieces "fit together" conceptually)
  - Substantial size (~5% of codebase, or significant enough to cause confusion)
  - Has a name worth tracking (you'd mention it when explaining architecture)

  A system is something you'd draw as a box in an architecture diagram.
  It's what you'd explain to a new team member as "the X that handles Y."

  NOT a system:
  - Individual functions or methods (use live scan via rivet check)
  - Utility helpers without conceptual identity
  - Single files that are just implementation details
  - Things too small to have a "name" worth locking

  When in doubt: if it's caused confusion before, or has a name that could
  drift or be misused, it's probably worth an entry. If not, leave it out.
