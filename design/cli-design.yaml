# ABOUTME: CLI design principles and command structure
# ABOUTME: Simple, sexy, well-thought-out syntax

principles:
  - CLI native - command-line tool first
  - Simple and sexy syntax
  - Minimal typing for common operations
  - Auto-commit each change for granular undo
  - Single tool use, multiple commits when batching
  - Pure CLI - no interactive modes or $EDITOR

auto_commit:
  description: |
    Every rivet command that modifies rivet.yaml automatically commits the change.
    Single tool use, atomic operation, git handles undo.

  behavior: |
    1. Read rivet.yaml
    2. Make change
    3. Write rivet.yaml
    4. git add rivet.yaml
    5. git commit -m "rivet: <operation description>"

  batch_behavior: |
    When using rivet sync with multiple operations, each operation gets its
    own commit in sequence. One tool use, multiple commits.

  flags:
    --no-commit: "Skip auto-commit for this operation"

# Schema reference: see schema-draft.yaml for system fields
# Editable fields: description, requirement, decision, term, status,
#                  depends_on, used_by, differs_from

commands:

  #============================================================================
  # STANDALONE COMMANDS
  #============================================================================

  init:
    usage: "rivet init [--minimal]"
    description: "Initialize Rivet in a project."

  context:
    usage: "rivet context [system...]"
    description: |
      Output context for AI consumption. Dumps project info, systems,
      requirements, relationships.
    examples:
      - "rivet context              # all systems"
      - "rivet context Router       # just Router"
      - "rivet context Router Config # multiple systems"

  sync:
    usage: "rivet sync [operations...]"
    description: |
      Run multiple operations in one command. Each operation gets its own
      commit for granular undo. This is THE command for end-of-session updates -
      capture all systems, requirements, decisions, terms, and glossary in one call.
    examples:
      - "rivet sync --system-add Router 'handles routing' --system-deprecate OldRouter"
      - "rivet sync --system-add Foo 'desc' --system-require Foo 'must do X'"
      - "rivet sync --term-define vibe_coding 'AI handles implementation'"
    flags:
      --system-add: "<name> <description>"
      --system-require: "<system> <statement>"
      --system-decide: "<system> <statement>"
      --system-edit: "<system> <field> <value>"
      --system-link: "<system> --depends-on|--used-by <other>"
      --system-deprecate: "<name> [--replaced-by <new>]"
      --term-define: "<term> <definition>"
      --term-rename: "<old> <new>"

  check:
    usage: "rivet check"
    description: |
      Grep codebase for terms, report matches/mismatches.
      Also cleans up 'previously' fields for terms no longer in codebase.

  purge:
    usage: "rivet purge <term>"
    description: |
      Low-level utility: remove a term from the codebase. Uses ripgrep to find
      all occurrences, then AI decides what to do (delete, rename, refactor).
      Not about rivet.yaml - about cleaning up actual code.
    examples:
      - "rivet purge oldFunctionName    # AI removes/replaces all occurrences"

  harvest:
    usage: "rivet harvest"
    description: |
      Bootstrap Rivet from an existing project. Scans codebase for systems,
      parses AI transcripts for requirements/decisions, generates draft rivet.yaml.

  #============================================================================
  # SYSTEM SUBCOMMANDS: rivet system <subcommand>
  #============================================================================

  system_add:
    usage: "rivet system add <name> <description>"
    description: "Add a new system"
    commit_message: "rivet: system add <name>"

  system_show:
    usage: "rivet system show <name>"
    description: "Show details of one system (read-only)"

  system_list:
    usage: "rivet system list [--status <status>]"
    description: "List all systems (read-only)"

  system_edit:
    usage: "rivet system edit [<system>] [<field>] [+|-]<value>"
    description: |
      Edit a system's fields. Pure CLI, no interactive mode.
      Without args, shows available fields from schema.
      With just system name, shows current values.
    examples:
      - "rivet system edit                              # show editable fields"
      - "rivet system edit Router                       # show Router's values"
      - "rivet system edit Router description 'new desc'"
      - "rivet system edit Router +requirement 'must do X'"
      - "rivet system edit Router -requirement 'old req'"
      - "rivet system edit Router +decision 'async-first'"
      - "rivet system edit Router +term createRouter 'factory function'"
      - "rivet system edit Router +term RouterProvider"  # null context
      - "rivet system edit Router status deprecated"
    fields:
      description: "string (replace)"
      requirement: "list (+add / -remove)"
      decision: "list (+add / -remove)"
      term: "map (+add / -remove) - term with optional context"
      status: "enum: active | deprecated | replacing:<system>"
      depends_on: "list (+add / -remove)"
      used_by: "list (+add / -remove)"
      differs_from: "list (+add / -remove)"
    commit_message: "rivet: system edit <system> <field>"

  system_link:
    usage: "rivet system link <system> --depends-on|--used-by <other>"
    description: "Add relationship between systems"
    commit_message: "rivet: system link <system> -> <other>"

  system_deprecate:
    usage: "rivet system deprecate <system> [--replaced-by <new>]"
    description: "Mark system as deprecated"
    commit_message: "rivet: system deprecate <system>"

  #============================================================================
  # TERM SUBCOMMANDS: rivet term <subcommand> (project-wide glossary)
  #============================================================================

  term_define:
    usage: "rivet term define <term> <definition>"
    description: |
      Add a PROJECT-WIDE glossary term. These are concepts, jargon, conventions
      that apply across the entire codebase - not tied to any specific system.
    commit_message: "rivet: term define <term>"
    examples:
      - "rivet term define vibe_coding 'AI handles implementation while human guides'"
      - "rivet term define premature_reification 'casual language formalized before agreement'"

  term_rename:
    usage: "rivet term rename <old> <new>"
    description: |
      Rename a glossary term. Updates rivet.yaml and adds a 'previously' field
      to help AI understand the transition. The 'previously' field is temporary -
      removed by 'rivet check' once the old term is purged from the codebase.
    commit_message: "rivet: term rename <old> → <new>"

  term_delete:
    usage: "rivet term delete <term>"
    description: "Remove a term from the glossary."
    commit_message: "rivet: term delete <term>"

  term_list:
    usage: "rivet term list"
    description: "Show all project-wide glossary terms."

  #============================================================================
  # VIEW COMMANDS (read-only)
  #============================================================================

  arch:
    usage: "rivet arch"
    aliases: ["architecture"]
    description: "Show architecture overview - all systems and relationships"

  reqs:
    usage: "rivet reqs [system]"
    description: "Show requirements. All, or filtered to one system."

  terms:
    usage: "rivet terms"
    description: "Show all terms - both system-level and project glossary"

  orphans:
    usage: "rivet orphans"
    description: "Find orphaned requirements (parent system deprecated/removed)"

  history:
    usage: "rivet history [system] [--requirement <req>] [--decision <dec>]"
    description: |
      Show provenance of requirements/decisions via git history.
      When was it added? By whom? In what context?
    examples:
      - "rivet history Router                         # all changes to Router"
      - "rivet history --requirement 'must handle X'  # when was this added?"

  #============================================================================
  # LAYOUT (optional codebase organization)
  #============================================================================

  layout:
    usage: "rivet layout [flavor]"
    description: "Show current layout, or set to a flavor"
    examples:
      - "rivet layout                # show current"
      - "rivet layout standard-ts    # adopt standard-ts layout"
      - "rivet layout check          # verify codebase matches layout"

# Workflow summary:
# 1. rivet context → AI gets context
# 2. Conversation about changes, naming negotiation
# 3. AI runs commands (rivet system/term or rivet sync for batch)
# 4. Each change auto-committed
# 5. Don't like something? git revert the specific commit
