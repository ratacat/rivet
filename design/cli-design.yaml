# ABOUTME: CLI design principles and command structure
# ABOUTME: Simple, sexy, well-thought-out syntax

principles:
  - CLI native - command-line tool first
  - Simple and sexy syntax
  - Minimal typing for common operations
  - Auto-commit each change for granular undo
  - Single tool use, multiple commits when batching

auto_commit:
  description: |
    Every rivet command that modifies rivet.yaml automatically commits the change.
    Single tool use, atomic operation, git handles undo.

  behavior: |
    1. Read rivet.yaml
    2. Make change
    3. Write rivet.yaml
    4. git add rivet.yaml
    5. git commit -m "rivet: <operation description>"

  batch_behavior: |
    When using rivet sync with multiple operations, each operation gets its
    own commit in sequence. One tool use, multiple commits.

    Example: rivet sync --add Router "..." --deprecate OldRouter
    Creates two commits:
      1. "rivet: add Router"
      2. "rivet: deprecate OldRouter"

    Each can be reverted individually with git revert.

  flags:
    --no-commit: "Skip auto-commit for this operation"

commands:

  # Context / Reading
  context:
    usage: "rivet context [system...]"
    description: |
      Output context for AI consumption. Dumps project info, systems,
      requirements, relationships.
    examples:
      - "rivet context              # all systems"
      - "rivet context Router       # just Router"
      - "rivet context Router Config # multiple systems"

  # Core operations (each auto-commits)
  init:
    usage: "rivet init [--minimal]"
    description: "Initialize Rivet in a project. Interactive or minimal."

  add:
    usage: "rivet add <name> <description>"
    description: "Add a new system"
    commit_message: "rivet: add <name>"

  show:
    usage: "rivet show <name>"
    description: "Show details of one system (no commit, read-only)"

  list:
    usage: "rivet list [--status <status>]"
    description: "List all systems (no commit, read-only)"

  require:
    usage: "rivet require <system> <statement>"
    description: "Add requirement to a system (the WHAT)"
    commit_message: "rivet: require <system> '<statement>'"

  decide:
    usage: "rivet decide <system> <statement>"
    description: "Add a design decision to a system (the WHY)"
    commit_message: "rivet: decide <system> '<statement>'"

  lock:
    usage: "rivet lock <system> <identifier>"
    description: |
      Lock a code identifier to a specific system. These are function names,
      class names, variable names - locked to that system's namespace.
      For project-wide glossary terms, use 'rivet term define'.
    commit_message: "rivet: lock <system> <identifier>"
    examples:
      - "rivet lock Router createRouter      # createRouter belongs to Router"
      - "rivet lock Config loadConfig        # loadConfig belongs to Config"

  purge:
    usage: "rivet purge <term>"
    description: |
      Low-level utility: remove a term from the codebase. Uses ripgrep to find
      all occurrences, then AI decides what to do (delete, rename, refactor).
      Not about rivet.yaml - about cleaning up actual code.
    examples:
      - "rivet purge oldFunctionName    # AI removes/replaces all occurrences"

  # Term management (subcommands for project-wide glossary)
  term_define:
    usage: "rivet term define <term> <definition>"
    description: |
      Add a PROJECT-WIDE glossary term. These are concepts, jargon, conventions
      that apply across the entire codebase - not tied to any specific system.
    commit_message: "rivet: term define <term>"
    examples:
      - "rivet term define vibe_coding 'AI handles implementation while human guides'"
      - "rivet term define harvest 'extracting requirements from transcripts'"

  term_rename:
    usage: "rivet term rename <old> <new>"
    description: |
      Rename a glossary term. Updates rivet.yaml and adds a 'previously' field
      to help AI understand the transition. The 'previously' field is temporary -
      removed once the old term is purged from the codebase.
    commit_message: "rivet: term rename <old> → <new>"

  term_delete:
    usage: "rivet term delete <term>"
    description: "Remove a term from the glossary."
    commit_message: "rivet: term delete <term>"

  term_list:
    usage: "rivet term list"
    description: "Show all project-wide glossary terms."

  link:
    usage: "rivet link <system> --depends-on|--used-by <other>"
    description: "Add relationship between systems"
    commit_message: "rivet: link <system> -> <other>"

  deprecate:
    usage: "rivet deprecate <system> [--replaced-by <new>]"
    description: "Mark system as deprecated, optionally specify replacement"
    commit_message: "rivet: deprecate <system> [replaced by <new>]"

  # Batch operations
  sync:
    usage: "rivet sync [operations...]"
    description: |
      Run multiple operations in one command. Each operation gets its own
      commit for granular undo. This is THE command for end-of-session updates -
      capture all systems, requirements, decisions, terms, and glossary in one call.
    examples:
      - "rivet sync --add Router 'handles routing' --deprecate OldRouter"
      - "rivet sync --add Foo 'desc' --require Foo 'must do X' --term Foo createFoo"
      - "rivet sync --define vibe_coding 'AI handles implementation' --decide Router 'async-first for scale'"
    flags:
      --add: "<name> <description>"
      --require: "<system> <statement>"
      --decide: "<system> <statement>"
      --lock: "<system> <identifier>"
      --term-define: "<term> <definition>"
      --link: "<system> --depends-on|--used-by <other>"
      --deprecate: "<name> [--replaced-by <new>]"

  # Views (read-only, no commits)
  arch:
    usage: "rivet arch"
    aliases: ["architecture"]
    description: "Show architecture overview - all systems and relationships"

  reqs:
    usage: "rivet reqs [system]"
    description: "Show requirements. All, or filtered to one system."

  terms:
    usage: "rivet terms"
    description: "Show all locked terms - both system terms and project glossary"

  # Checking (read-only, no commits)
  check:
    usage: "rivet check"
    description: "Grep codebase for terms, report matches/mismatches"

  orphans:
    usage: "rivet orphans"
    description: "Find orphaned requirements (parent system deprecated/removed)"

  history:
    usage: "rivet history [system] [--requirement <req>] [--decision <dec>]"
    description: |
      Show provenance of requirements/decisions via git history.
      When was it added? By whom? In what context?
    examples:
      - "rivet history Router                    # all changes to Router"
      - "rivet history --requirement 'must handle X'  # when was this added?"

  # Layout (optional codebase organization)
  layout:
    usage: "rivet layout [flavor]"
    description: "Show current layout, or set to a flavor"
    examples:
      - "rivet layout                # show current"
      - "rivet layout standard-ts    # adopt standard-ts layout"
      - "rivet layout check          # verify codebase matches layout"

# Workflow summary:
# 1. rivet context → AI gets context
# 2. Conversation about changes, naming negotiation
# 3. AI runs commands (direct or sync)
# 4. Each change auto-committed
# 5. Don't like something? git revert the specific commit
